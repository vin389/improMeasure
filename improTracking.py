import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
from matplotlib.backend_bases import FigureCanvas 

def gridTrackingOpf(files, gridDim, winSize):
    """
    This function runs optical flow analysis about a grid of points
    through a list of image files.
    Note: This function can be time consuming.
    Parameters
    ----------
    files : TYPE list of strings
        list of (full-path of) image files
    gridDim : TYPE: int, (int,int), [int, int], or np.array([int,int])
        number of tracking points in the grid.
    wsize: TYPE : int
        window size

    Returns
    -------
    points : np.ndarray((nfiles, npoints, 2), np.float32)
    status : np.ndarray((nfiles, npoints), np.uint8)
    err    : np.ndarray((nfiles, npoints), np.float32))
    """
    nfiles = len(files)
    npoints = gridDim[0] * gridDim[1]

    # allocate memory
    points = np.zeros((nfiles, npoints, 2), dtype=np.float32)
    status = np.zeros((nfiles, npoints), dtype=np.uint8)
    err    = np.zeros((nfiles, npoints), dtype=np.float32)

    # define initial points
    img0 = cv.imread(files[0], cv.IMREAD_GRAYSCALE)
    imgSize = img0.shape
    gridDy = imgSize[0] / gridDim[0]
    gridDx = imgSize[1] / gridDim[1]
    ys = np.linspace(-0.5 + 0.5 * gridDy, -0.5 + imgSize[0] - 0.5 * gridDy, gridDim[0])
    xs = np.linspace(-0.5 + 0.5 * gridDx, -0.5 + imgSize[1] - 0.5 * gridDx, gridDim[1])
    ipoint = 0
    for iy in range(gridDim[0]):
        for ix in range(gridDim[1]):
            points[0, ipoint, 0] = xs[ix]
            points[0, ipoint, 1] = ys[iy]

    # run loop through files
    for ifile in range(nfiles):
        prevImg = img0.copy()
        nextImg = cv.imread(files[ifile], cv.IMREAD_GRAYSCALE)
        prevPts = points[ifile, :, :].reshape(-1, 2)
        st = status[ifile, :].copy()
        nextPts, st, er = cv.calcOpticalFlowPyrLK(prevImg, nextImg, prevPts, winSize=winSize)
        
def improShowMassTracking(imgFile, npzFile, winDim, winTitle):
    """
    This function displays the mass tracking result by an interactive window.
    The left part of the window is the background image that allows user to select the cell
    to display by swiping mouse through it.
    The right part of the window is four sub-plots displaying the tracking results, including
    the image displacements ux and uy, the tracking errors, and the status (from optical flow).

    Parameters
    ----------
    imgFile : np.ndarray (h,w,3) BGR (OpenCV) format
        the image to display at the left part of this window, supposed to be the initial
        image of this tracking
    npzFile : str
        the file that generated by mass-tracking function, containing the following
    winDim : np.ndarray

    winTitle : str



    Returns
    -------
    """
    # load data
    npzData = np.load(npzFile)
    points = npzData['points']
    status = npzData['status']   # shape: (nStep, gridDim[0] * gridDim[1])
    errors = npzData['err']      # shape: (nStep, gridDim[0] * gridDim[1])
    gridDim = npzData['griddim'] # dimension of grid (number of points) (Ny, Nx)
    winSize = npzData['winsize'] # window size. (winSizeX, winSizeY) (or winSizeY, winSizeX? Same with cv.calcOpticalFlowPyrLK)
    npzData.close()
    showH = winDim[0]
    showW = winDim[1]
    showImg = np.zeros((showH, showW, 3), dtype=np.uint8)

    # background image
    bgImg = cv.imread(imgFile)
    bgScale = min(showH / bgImg.shape[0], 0.5 * showW / bgImg.shape[1])
    bgSizeS = (int(bgImg.shape[1] * bgScale + .5), int(bgImg.shape[0] * bgScale + .5))
    # resized (smaller) background image to fit the left part of show window
    bgImgS1 = cv.resize(bgImg, bgSizeS, interpolation=cv.INTER_LANCZOS4)
    # light version of background
    bgImgS2 = bgImgS1 + (np.ones(bgImgS1.shape, dtype=bgImgS1.dtype) * 255 - bgImgS1) // 2
    showImg[0:bgImgS1.shape[0], 0:bgImgS1.shape[1]] = bgImgS2

    def mouseEvent(event, x, y, flags, param):
#        global gridDim, winSize, bgScale, bgImgS1, bgImgS2, showImg
        # calculate grid coordinate according to how grid is defined.
        #    ys = np.linspace(-0.5 + 0.5 * gridDy, -0.5 + bgImgS1.shape[0] - 0.5 * gridDy, gridDim[0])
        #    xs = np.linspace(-0.5 + 0.5 * gridDx, -0.5 + bgImgS1.shape[1] - 0.5 * gridDx, gridDim[1])
        if y >= 0 and y < bgImgS1.shape[0] and x >= 0 and x < bgImgS1.shape[1]:
            gridDy = bgImgS1.shape[0] / gridDim[0]
            gridDx = bgImgS1.shape[1] / gridDim[1]
            gy = (y * gridDim[0]) // bgImgS1.shape[0]
            gx = (x * gridDim[1]) // bgImgS1.shape[1]
            gy = min(max(gy, 0), gridDim[0] - 1)
            gx = min(max(gx, 0), gridDim[1] - 1)
            # calculate window (scaled to the shown background)
            winSizeSx = int(winSize[0] * bgScale + .5)
            winSizeSy = int(winSize[1] * bgScale + .5)
            y0 = max(0, min(int((gy + .5) * gridDy - .5 * winSizeSy + .5), bgImgS1.shape[0]))
            y1 = max(0, min(int((gy + .5) * gridDy + .5 * winSizeSy + .5), bgImgS1.shape[0]))
            x0 = max(0, min(int((gx + .5) * gridDx - .5 * winSizeSx + .5), bgImgS1.shape[1]))
            x1 = max(0, min(int((gx + .5) * gridDx + .5 * winSizeSx + .5), bgImgS1.shape[1]))
            # make window the original color while other parts the lightened color
            showImg[0:bgImgS1.shape[0], 0:bgImgS1.shape[1]] = bgImgS2
            showImg[y0:y1, x0:x1, :] = bgImgS1[y0:y1, x0:x1, :]
            # get data to display
            pointIdx = gy * gridDim[1] + gx
            tStep = np.arange(1, points.shape[0] + 1)
            ux = points[:,pointIdx,0].reshape(-1)
            ux = ux - ux[0]
            # plot 2
            uy = points[:,pointIdx,1].reshape(-1)
            uy = uy - uy[0]
            st = status[:,pointIdx].reshape(-1)
            er = errors[:,pointIdx].reshape(-1)
            # plot data on a canvas (using Matplotlib)
            dpi=100
            fig = plt.Figure(figsize=(showW/2/dpi, showH/1/dpi), dpi=dpi)
            canvas = FigureCanvas(fig)
            ax1 = fig.add_subplot(311)
            ax1.plot(tStep, ux); ax1.grid(True)
            ax1.set_ylabel('Ux (pixels)')
            ax2 = fig.add_subplot(312)
            ax2.plot(tStep, uy); ax2.grid(True)
            ax2.set_ylabel('Uy (pixels)')
            ax3 = fig.add_subplot(313)
            ax3.plot(tStep, er); ax3.grid(True)
            ax3.set_ylabel('Tracking error')
#            ax4 = fig.add_subplot(414)
#            ax4.plot(tStep, st); ax4.grid(True)
#            ax4.set_ylabel('Tracking status (succeeded or failed)')
            ax3.set_xlabel('Camera step')
            canvas.draw()
            buf = canvas.buffer_rgba()
            buf = cv.cvtColor(np.asarray(buf), cv.COLOR_RGBA2BGR)
            buf = cv.resize(buf, (showImg.shape[1] // 2, showImg.shape[0] // 1))
            y0 = 0; y1 = y0 + buf.shape[0]
            x0 = showImg.shape[1] // 2; x1 = x0 + buf.shape[1]
            showImg[y0:y1, x0:x1] = buf
            cv.imshow(winTitle, showImg)
            print("\b" * 100, end='')
            print("Grid coordinate: %4d %4d. Idx: %d " % (gy, gx, pointIdx), end='', flush=True)

    cv.namedWindow(winTitle)
    cv.setMouseCallback(winTitle, mouseEvent)

    cv.imshow(winTitle, showImg)
    cv.waitKey(0)
    try:
        cv.destroyWindow(winTitle)
    except:
        pass

def test_improShowMassTracking():
#    imgFile = r'D:\ExpDataSamples\20221100_SteelFrames\20221109\FUJI_L_1967\DSC06874.JPG'
#    npzFile = r'D:\yuansen\ImPro\improMeasure\examples\massTracking\ofile1.npz'
#    imgFile = r'D:\yuansen\ImPro\improMeasure\examples\massTracking\20220310_C1\IMG_1835.JPG'
#    imgFile = r'D:\yuansen\ImPro\improMeasure\examples\massTracking\20220310_C1\IMG_2233.JPG'
#    npzFile = r'D:\yuansen\ImPro\improMeasure\examples\massTracking\ofile_20220310_C1.npz'
    imgFile = r'D:\ExpDataSamples\20221100_SteelFrames\20221129\FilesAligned_Fuji_L\DSC1195.JPG'
    npzFile = r'D:\ExpDataSamples\20221100_SteelFrames\20221129\Analysis_Fuji_L_MassOptFlow\ofile_20221129_Fuji_L.npz'
    showW = 1000
    showH = 400
    winTitle = "Mass Tracking Display. ImPro Measure 2022 ver.0.1 by ImPro Lab, TaipeiTech (NTUT)"
    improShowMassTracking(imgFile, npzFile, (showH, showW), winTitle)

if __name__ == '__main__':
    test_improShowMassTracking()        


